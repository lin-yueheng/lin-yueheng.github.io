---
title: java_SSM
abbrlink: 344860877
date: 2022-12-15 11:41:56
categories:
- [计算机科学, Java, 零基础学Java语言-浙江大学-翁恺]
tags:
---

# SSM_Spring+SpringMVC+Maven高级+SpringBoot+MyBatisPlus



![image-20221121115318582](java-SSM.assets/image-20221121115318582.png)

点解要学

- Spring技术是JavaEE开发的必备技能，企业开发技术选型命中率>90%

- 专业角度

用来简化开发，降低企业级开发的复杂性

框架整合，高效整合其他技术，以提高企业级应用程序开发与运行效率



- 简化开发

IOC

AOP

- ​			事务处理

框架整合

- MyBaties
- mybatis-plus
- Struts
- Struts2
- Hibernate



怎么学习



- 学习spring框架的设计思想
- 学习基础操作，思考操作与思想之间的联系
- 学习案例，熟练应用操作的同时，体验思想





初识spring



了解spring家族(Spring全家桶)

发展史(Spring 5.0)



# spring framework系统架构

-  Spring Framework是spring生态圈中最基础的项目，是其他项目的根基。

(1)核心层

- Core Container：核心容器，这个模块是spring最核心的模块，其他的都需要依赖该模块。

(2)AOP层

- AOP：面向切面编程，它依赖的是核心层容器，目的是==在不改变原有代码的前提下对其进行功能的增加。

(3)Aspects:AOP是思想，Aspects是对其AOP思想的具体实现

(3)数据层

- Data Access:数据访问层，Spring全家桶中有对数据访问的具体实现技术
- Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis
- Transaction:事务，spring中事务管理是spring AOP的一个具体实现，是一个重点。

(4)Web层

- 这一层的内容将在springMVC框架中具体学习

(5)Test层

- Spring主要整合了Junit来完成单元测试和集成测试



Spirng核心概念内容中主要包含IOC/DI、IOC容器和Bean。

(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象

(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署

(3)所以代码在编写的过程中存在的问题是：==耦合度偏高==

如何解决呢

![1629724206002](java-SSM.assets/1629724206002.png)

所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢

针对这个问题，Spring就提出了一个解决方案:

- 就是在适用对象的时候，在程序中不要主动使用new产生对象，转换为由外部提供对象

这种实现的思想就是spring的一个核心的概念



## 1 IOC、IOC容器、Bran、DI

1. IOD(Inversion of Control)控制反转

(1)什么是控制反转？

- 使用对象的时候，由主动new产生对象转换为由外部提供了对象，此过程就是对象创建控制权由程序转移到外部，这个思想就是控制反转。

(2)Spring和IOC之间的关系是啥？

- Spring技术对IOC思想进行了实现
- spring提供了一个容器，称为IOC容器，用来充当IOC思想中的“外部”
- IOC思想中的别人[外部]指的就是spring中的IOC容器

(3)IOC容器的作用以及内部存放的是什么？

- IOC容器负责的就是对象的创建、初始化等一系列工作，其中就包含了数据层业务层的对象。
- 别创建或被管理的对象在IOC容器中统称为Bean
- IOC容器中放的就是一个个的Bean对象

(4)当IOC容器中创建好service和dao对象之后，程序能正确执行吗?

- 不行，因为service运行徐娅以来dao对象
- IOC容器中虽然service和dao对象没有任何关系
- 需要把dao对象交给service，也就是说要绑定service和dao对象之间的关系



像这种在容器中建立对像与对象之间的绑定关系就要用到DI：

2. DI依赖注入

(1)什么是依赖注入呢？

- 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入

业务层要用到数据层的类对象，以前都是自己new的

现在要靠别人[外部指的就是IOC容器]来注入进来

(2)IOC容器中哪一些bean之间需要建立依赖关系呢？

- 这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系



### IOC入门案例的实现

**添加案例中需要的类：**

```java
public interface BookDao {
    public void save();
}
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface BookService {
    public void save();
}
public class BookServiceImpl implements BookService {
    private BookDao bookDao = new BookDaoImpl();
    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

在resource下添加spring配置文件applicationContext.xml，并完成bean的配置

```Java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
 
    <!--bean标签标示配置bean
    	id属性标示给bean起名字
    	class属性表示给bean定义类型
	-->
	<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl"/>

</beans>
```

获取IOC容器🚿

```java
public class App {
    public static void main(String[] args) {
        //获取IOC容器
        ApplicationContext context=new ClassPathXmlApplicationContext("applicationContext.xml");

        
        BookDao bookDao = (BookDao) context.getBean("bookDao");
        BookService bookService= (BookService) context.getBean("bookService");
        bookDao.save();
        bookService.save();
    }
}
```





DI入门案例

> 需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入
>
> 1.删除业务层中使用new的方式创建的dao对象
>
> 2.在业务层提供BookDao的setter方法
>
> 3.在配置文件中添加依赖注入的配置(property)
>
> 4.运行程序调用方法



### IOC相关的内容

bean基础配置

```xml
<bean id="" class=""/>
```

bean的name属性

配置别名

```XML
<bean id="" class="" name=""/>    以空格or,or;分隔开来，作用效果跟id一样
```



## 2 bean作用范围scope配置

```
scope="prototype"  这个就是非单例的
scope="singleton"  这个就是单例的
```

在默认的情况之下，spring创建的bean对象都是单例的



### scope使用的感受

为什么bean默认的情况之下都是为单例的呢？

- bean为单例的意思就是说在spring的IOC容器中只会有该类的一个对象

- bean对象只有一个就避免了对象的频繁创建跟销毁，达到了bean对象的复用，性能高。

bean在容器中是单例的话，会不会产生线程安全问题？

- 如果对象是有状态的对象，即该对象中有成员变量用来存储数据的。因为所有的请求共用一个bean对象，所以会存在线程安全问题。
- 如果对象是无状态的，即该对象没有成员变量没有进行数据存储的，因为方法中的局部变量在方法调用之后会被销毁，所以不会存在线程安全问题



哪些bean对象适合交给容器来进行管理

- 表现层对象
- 业务层对象
- 数据层对象
- 工具对象



哪些bean对象不适合交给容器来进行管理

- 封装是里的域对象，因为会引发线程安全问题，所以不适合。



bean基础配置的小结

关于bean的基础配置中

```XML
<bean id="bean的唯一标识"
class="bean的类全名"
scope="bean的作用范围,有singleton(默认)和propertype"
name="为wean取得别名"
">
```



## 3 bean的实例化

实例化的三种方法，构造方法，静态方法和实例工厂

bean本质上就是对象，对象在new的时候会使用构造方法完成，那么创建bean也是使用构造方法来完成的。





将BookDaoImpl中的构造方法设置为private

并且在里面打印一句话来测试

能执行成功，说明内部走的依旧是构造函数，能够访问类中的私有构造方法，显而易见spring底层用的就是反射。

```java
public class BookDaoImpl implements BookDao {
    private BookDaoImpl() {
        System.out.println("book dao constructor is running ....");
    }
    public void save() {
        System.out.println("book dao save ...");
    }

}	
```



构造函数中添加一个参数测试

程序会报错，说明spring底层使用的是类的无参构造方法

```java
public class BookDaoImpl implements BookDao {
    private BookDaoImpl(int i) {
        System.out.println("book dao constructor is running ....");
    }
    public void save() {
        System.out.println("book dao save ...");
    }

}
```



分析spring的错误信息

spring的报错信息来学一学如阅读。

- 错误信息从下往上来查看，因为上面的错误大都是西面错误的一个包装，最核心错误是在最下面



### 静态工厂实例化

(1)准备一个OrderDao和OrderDaoImpl类

```java
public interface OrderDao {
    public void save();
}

public class OrderDaoImpl implements OrderDao {
    public void save() {
        System.out.println("order dao save ...");
    }
}
```

(2)创建一个工厂类OrderDaoFactory并提供一个静态方法

```java
//静态工厂创建对象
public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
        return new OrderDaoImpl();
    }
}
```

(3)编写AppForInstanceOrder运行类，在类中创建工厂来获取对象

```java
public class AppForInstanceOrder {
    public static void main(String[] args) {
        //通过静态工厂创建对象
        OrderDao orderDao = OrderDaoFactory.getOrderDao();
        orderDao.save();
    }
}
```



(1)交给spring来进行管理

```xml
<bean id="orderDao" class="com.itheima.factory.OrderDaoFactory" factory-method="getOrderDao"/>
```

(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试

```java
public class AppForInstanceOrder {
    public static void main(String[] args) {
        ApplicationContext ctx=new ClassPathxmlApplicationContext("applicationContext.xml");
        
        
        
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        OrderDao orderDao = (OrderDao) ctx.getBean("orderDao");

        orderDao.save();

    }
}
```

- 静态工厂的方式反而更加复杂

主要的原因就是：

- 在工厂的静态方法中，我们除了new对象之外还可以做其他的一些业务操作，这些操作必不可少，如：

```java
public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
        System.out.println("factory setup....");//模拟必要的业务操作
        return new OrderDaoImpl();
    }
}
```

==静态工厂以了解为主==



实例化工厂与FactoryBean

前面的三个类擦不多都是一样的，只要把其中的静态方法改编成为普通的方法就行了

```java
public class AppForInstanceUser {
    public static void main(String[] args) {
        //创建实例工厂对象
        UserDaoFactory userDaoFactory = new UserDaoFactory();
        //通过实例工厂对象创建对象
        UserDao userDao = userDaoFactory.getUserDao();
        userDao.save();
}
```

接下来就是交给spring来管理



```xml
<bean id="userFactory" calss="com.ityueheng.foctory.UserDaoFactory"/>
<bean id="userDao" factory-method="getUserDao" factory-bean="UserFactory"/> 
```



实例化工厂运行的顺序就是：

- 创建实例化工厂对象，对应的第一行配置

- 调用对象中的方法来创建bean，对应的是第二行配置

factory-bean：工厂的实例化对象

factory-method：工厂对象中的具体创建对象的方法名。



```java
public class AppForInstanceUser {
    public static void main(String[] args) {
        ApplicationContext ctx = new 
            ClassPathXmlApplicationContext("applicationContext.xml");
        UserDao userDao = (UserDao) ctx.getBean("userDao");
        userDao.save();
    }
}
```





FactoryBean的使用

具体的使用步骤为：

1）创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口中的方法



```java
public class UserDaoFactoryBean implements FactoryBean<UserDao> {
    //代替原始实例工厂中创建对象的方法
    public UserDao getObject() throws Exception {
        return new UserDaoImpl();
    }
    //返回所创建类的Class对象
    public Class<?> getObjectType() {
        return UserDao.class;
    }
}
```



### bean的生命周期

* 首先理解下什么是生命周期?
  * 从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。
* bean生命周期是什么?
  * bean对象从创建到销毁的整体过程。
* bean生命周期控制是什么?
  * 在bean创建后到销毁前做一些事情。

#### 环境准备

- 创建一个Maven项目
- pom.xml添加依赖
- resources下添加spring的配置文件applicationContext.xml

(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类

```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
}

public interface BookService {
    public void save();
}

public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```

(2)resources下提供spring的配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
</beans>
```

(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象

```java
public class AppForLifeCycle {
    public static void main( String[] args ) {
        ApplicationContext ctx = new 
        	ClassPathXmlApplicationContext("applicationContext.xml");
        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();
    }
}
```

#### 生命周期设置

在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:

* bean创建之后，想要添加内容，比如用来初始化需要用到资源
* bean销毁之前，想要添加内容，比如用来释放用到的资源

##### 步骤1:添加初始化和销毁方法

针对这两个阶段，BooDaoImpl类中分别添加两个方法，==方法名任意==

```java
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
    //表示bean初始化对应的操作
    public void init(){
        System.out.println("init...");
    }
    //表示bean销毁前对应的操作
    public void destory(){
        System.out.println("destory...");
    }
}
```

##### 步骤2:配置生命周期

在配置文件添加配置，如下:

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory"/>
```

##### 步骤3:运行程序

运行AppForLifeCycle打印结果为:

从结果中可以看出，init方法执行了，但是destroy方法却未执行

* Spring的IOC容器是运行在JVM中
* 运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行
* main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了
* 所以没有调用对应的destroy方法

#### close关闭容器

* ApplicationContext中没有close方法

* 需要将ApplicationContext更换成ClassPathXmlApplicationContext

  ```java
  ClassPathXmlApplicationContext ctx = new 
      ClassPathXmlApplicationContext("applicationContext.xml");
  ```

* 调用ctx的close()方法

  ```
  ctx.close();
  ```

#### 注册钩子关闭容器

* 在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器

* 调用ctx的registerShutdownHook()方法

  ```
  ctx.registerShutdownHook();
  ```

  **注意:**registerShutdownHook在ApplicationContext中也没有

* 运行后，查询打印结果


相同点:这两种都能用来关闭容器

不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。

分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。

Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置`init-method`和`destroy-method`

接下来在BookServiceImpl完成这两个接口的使用:

修改BookServiceImpl类，添加两个接口`InitializingBean`， `DisposableBean`并实现接口中的两个方法`afterPropertiesSet`和`destroy`

```java
public class BookServiceImpl implements BookService, InitializingBean, DisposableBean {
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
    public void save() {
        System.out.println("book service save ...");
        bookDao.save(); 
    }
    public void destroy() throws Exception {
        System.out.println("service destroy");
    }
    public void afterPropertiesSet() throws Exception {
        System.out.println("service init");
    }
}
```

**小细节**

* 对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为`属性设置之后`。

* 对于BookServiceImpl来说，bookDao是它的一个属性

* setBookDao方法是Spring的IOC容器为其注入属性的方法

  * 从方法名分析，猜想应该是setBookDao方法先执行

  * 验证思路，在setBookDao方法中添加一句话

    ```java
    public void setBookDao(BookDao bookDao) {
            System.out.println("set .....");
            this.bookDao = bookDao;
        }
    
    ```

  * 重新运行AppForLifeCycle，打印结果如下:


#### bean生命周期小结

(1)关于Spring中对bean生命周期控制提供了两种方式:

* 在配置文件中的bean标签中添加`init-method`和`destroy-method`属性
* 类实现`InitializingBean`与`DisposableBean`接口

(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:

* 初始化容器
  * 1.创建对象(内存分配)
  * 2.执行构造方法
  * 3.执行属性注入(set操作)
  * ==4.执行bean初始化方法==
* 使用bean
  * 1.执行业务操作
* 关闭/销毁容器
  * ==1.执行bean销毁方法==

(3)关闭容器的两种方式:

* ConfigurableApplicationContext是ApplicationContext的子类
  * close()方法
  * registerShutdownHook()方法



## 4 DI相关内容



### Setter注入

在bean中定义引用类型属性，并提供可访问的set方法

```JAVA
public class BookServiceImpl implements BookService {
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
}
```

配置中使用property标签ref属性注入引用类型对象

```xml
<bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
	<property name="bookDao" ref="bookDao"/>
</bean>

<bean id="bookDao" class="com.itheima.dao.imipl.BookDaoImpl"/>
```



```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface UserDao {
    public void save();
}
public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("user dao save ...");
    }
}

public interface BookService {
    public void save();
}

public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



引用类型的注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>
</beans>
```



setter方式的注入

对于引用数据类型的使用的是<property name="" ref=""/>

对于简单数据类型的使用就是<property name="" value=""/>



## 5 构造器的注入

构造器注入也就是构造方法的注入

```java
public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {
    
    private String databaseName;
    private int connectionNum;
    
    public void save() {
        System.out.println("book dao save ...");
    }
}
public interface UserDao {
    public void save();
}
public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("user dao save ...");
    }
}

public interface BookService {
    public void save();
}

public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



构造器注入引用数据类型

> 需求：将BookServiceImpl类中的bookDao修改成为使用构造器的方式注入
>
> 1. 将bookDao中的setter方法删除
> 2. 添加带有bookDao参数的构造方法
> 3. 在applicationContext.xml中进行配置



```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public BookServiceImpl(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.ityueheng.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.ityueheng.service.impl.BookServiceImpl">
       重点： <constructor-arg name="bookDao" ref="bookDao"/>
    </bean>
</beans>
```



标签<constructor-arg>中

- name属性对应的值为构造函数中的方法形参的参数名，必须要保持一致
- ref属性指向的是spring的IOC容器中的其他bean对象



构造器中注入多个引用的数据类型

> 需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao
>
> 1. 声明userDao属性
>
> 2. 生成一个带有bookDao和userDao参数的构造函数
> 3. 在applicationContext.xml中配置注入



1.**提供多个属性的构造函数**

```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;
    private UserDao userDao;

    public BookServiceImpl(BookDao bookDao,UserDao userDao) {
        this.bookDao = bookDao;
        this.userDao = userDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
        userDao.save();
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
        <constructor-arg name="userDao" ref="userDao"/>
    </bean>
</beans>
```



#### 构造器注入多个简单数据类型

> 需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。
>
> 参考引用数据类型的注入，我们可以推出具体的步骤为:
>
> 1.提供一个包含这两个参数的构造方法
>
> 2.在applicationContext.xml中进行注入配置

##### 步骤1:添加多个简单属性并提供构造方法

修改BookDaoImpl类，添加构造方法

```java
public class BookDaoImpl implements BookDao {
    private String databaseName;
    private int connectionNum;

    public BookDaoImpl(String databaseName, int connectionNum) {
        this.databaseName = databaseName;
        this.connectionNum = connectionNum;
    }

    public void save() {
        System.out.println("book dao save ..."+databaseName+","+connectionNum);
    }
}
```

##### 步骤2:配置完成多个属性构造器注入

在applicationContext.xml中进行注入配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <constructor-arg name="databaseName" value="mysql"/>
        <constructor-arg name="connectionNum" value="666"/>
    </bean>
    <bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
        <constructor-arg name="userDao" ref="userDao"/>
    </bean>
</beans>
```

**说明:**这两个`<contructor-arg>`的配置顺序可以任意

##### 步骤3:运行程序

运行AppForDIConstructor类，查看结果



上面已经完成了构造函数注入的基本使用，但是会存在一些问题:



* 当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变
* 这两块存在紧耦合



方式一：删除name属性，添加type属性，然后按照类型注入

```xml
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
    <constructor-arg type="int" value="10"/>
    <constructor-arg type="java.lang.String" value="mysql"/>
</bean>
```

- 这种方式可以解决构造函数形参名发生变化带来的耦合性
- 但是如果构造方法参数中有类型相同的参数，这种方式不太适合

方式二：删除type属性，添加index属性，按照索引下标注入，下标是从零开始的

```
<bean id="bookDaO class="com.ityueheng.dao.impl.BookDaoImpl">
  <constructor-arg index="0" value="100">
  <constructor-arg index="1" value="mysql">
  </bean>
```

- 这种方式可以解决参数类型重复问题
- 但是如果构造方法参数顺序发生改变之后，这种方式又带来了耦合问题



该如何选择

1. 强制依赖使用构造器注入，使用setter注入有概率不进行注入导致null对象出现

强制依赖指的是对象在创建的时候就必须要注入指定的对象

2. 可选依赖使用setter注入进行，灵活性比较强

可选依赖指的是对象在创建过程中必须要注入指定的参数

3. spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对来说比较严谨
4. 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入
5. 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须要使用构造器方法注入
6. 自己开发的模块中推荐使用的是setter注入



setter注入

- 简单数据类型

```xml
<bean ...>
    <prperty name="" value=""/>
</bean>
```



- 引用数据类型

```xml
<bean ...>
  <property name="" ref=""/>
</bean>
```



构造器注入

- 简单数据类型

```xml
<bean ...>
  <constructor-arg name="" index="" type="" value=""/>
  </bean>
```

- 引用数据类型

```xml
<bean ...>
     <constructor-arg name="" index="" type="" ref=""/>
</bean>
```

依赖注入的方式选择上

- 建议使用setter注入
- 第三方技术根据情况选择



## 6 自动配置

什么是依赖自动装配？

- IOC容器根据bean所依赖资源在容器中自动查找并注入到bean中的过程称为自动装配



自动类型装配有哪些

- 按照类型（常用）
- 按照名称
- 按照构造方法
- 不启用自动装配



### 完成自动装配的配置

自动装配只需要修改applicationContext.xml配置文件即可；

1）将<property>标签删除

2）在<bean>标签中添加autowire属性



```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.itheima.dao.impl.BookDaoImpl"/>
    <!--autowire属性：开启自动装配，通常使用按类型装配-->
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byType"/>

</beans>
```

注意事项：

- 需要注入属性的类中对应的属性的setter方法不能省略
- 被注入的对象必须要被spring的IOC容器管理
- 按照类型在spring的IOC容器中如果找到多个对象，会报NoUniqueBeanDefinitionException

一个类型在IOC中有多个对象，还想要注入成功，这个时候就必须要按照名称来进行注入，配置方式为：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.itheima.dao.impl.BookDaoImpl"/>
    <!--autowire属性：开启自动装配，通常使用按类型装配-->
    <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl" autowire="byName"/>

</beans>
```

注意事项：

- 按照名称注入中的名称指的是什么？



![image-20221203184643869](https://raw.githubusercontent.com/lin-yueheng/IMG_01/main/img/202212031846014.png)

bookDao是private修饰的，外部类无法进行访问

对于外部类来说只能进行set方法访问

对于外部来说，setBookDao方法名称，set后首字母小写之后就是其属性名称

- 如果按照名称去找对应的bean对象，找不到则注入null
- 当某一种类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不然会报错

用的更多的是按照类型注入

1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作
2. 使用按类型装配时(byType)必须要保证容器中的相同类型的bean唯一，推荐使用
3. 使用按照名次装配时(byName)必须要保障容器中具有指定名称的bean，因变量与配置耦合，不推荐使用
4. 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效



## 7 集合注入

常见的集合类型有：

- 数组
- List
- Set
- Map
- Properties

1）public interface BookDao {
    public void save();
}

public class BookDaoImpl implements BookDao {
    
public class BookDaoImpl implements BookDao {

```java
private int[] array;

private List<String> list;

private Set<String> set;

private Map<String,String> map;

private Properties properties;

 public void save() {
    System.out.println("book dao save ...");

    System.out.println("遍历数组:" + Arrays.toString(array));

    System.out.println("遍历List" + list);

    System.out.println("遍历Set" + set);

    System.out.println("遍历Map" + map);

    System.out.println("遍历Properties" + properties);
}
//setter....方法省略，自己使用工具生成
```

}





(2)resources下提供spring的配置文件，applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
</beans>
```



(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象

```java
public class AppForDICollection {
    public static void main( String[] args ) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();
    }
}
```



### 注入数组类型数据

```xml
<property name="array">
<array>
        <value>  100  </value>
        <value>  100  </value>
        <value>  100  </value>
    </array>
</property>
```





#### 注入List类型数据

```xml
<property name="list">
    <list>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>chuanzhihui</value>
    </list>
</property>
```

#### 

#### 注入Set类型数据

```xml
<property name="set">
    <set>
        <value>itcast</value>
        <value>itheima</value>
        <value>boxuegu</value>
        <value>boxuegu</value>
    </set>
</property>
```

#### 

#### 注入Map类型数据

```xml
<property name="map">
    <map>
        <entry key="country" value="china"/>
        <entry key="province" value="henan"/>
        <entry key="city" value="kaifeng"/>
    </map>
</property>
```

#### 

## 8 注入Properties类型数据



```xml
<properties name="properties">
<props>
    <prop key="country">china</prop>
        <prop key="city">beijing</prop>
    </props>
</properties>
```



说明;

- properties标签中表示setter方式注入，构造方式conStructor-arg标签内部也可以写<array>。。。。
- List的底层也是用数组实现的，所以<List>和<array>标签是可以混用的
- 集合中要添加引用类型、只需要把<value>标签改成<ref>标签，这种方式使用的比较少



## 9 IOC/DI配置管理第三方bean

数据源对象管理



> 需求：使用Spring的IOC容器来管理Druid连接池对象
>
> 1. 使用第三方的技术，需要在pom.xml添加依赖
> 2. 在配置文件中将【第三方的类】制作成一个bean，让IOC容器来进行管理
> 3. 数据库连接池需要基础的四要素 驱动、连接、用户名、密码，【如何注入】到对应的bean中
> 4. 从IOC容器中获取对应的bean对象，将其打印到控制台中查看结果



pom.xml中添加依赖

配置第三方的bean

在applicationContext.xml配置文件中添加DruidDataSource的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--管理DruidDataSource对象-->
    <bean class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
</beans>
```





### 配置第三方bean

在applicationContext.xml配置文件中添加`DruidDataSource`的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--管理DruidDataSource对象-->
    <bean class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
</beans>
```

**说明:**

* driverClassName:数据库驱动
* url:数据库连接地址
* username:数据库连接用户名
* password:数据库连接密码
* 数据库连接的四要素要和自己使用的数据库信息一致。

### 从IOC容器中获取对应的bean对象

```java
public class App {
    public static void main(String[] args) {
       ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
       DataSource dataSource = (DataSource) ctx.getBean("dataSource");
       System.out.println(dataSource);
    }
}
```

##### 



### 实现c3p0管理

配置第三方bean



在applicationContext.xml配置文件中添加配置



```xml
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_db"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
    <property name="maxPoolSize" value="1000"/>
</bean>
```



- ComboPooleDataSource的属性是通过setter方式注入
- 想注入的属性就需要在ComboPooleDataSource类或者是上层类中提供属性对应的setter方法
- C3P0的四个属性和Druid的四个属性是不一样的



注意：

- 数据连接池在配置属性的时候，除了可以注入数据库连接四个要素之外还可以配置很多其他的属性，具体都有哪些属性需要自己去查
  - Druid和C3P0在没有导入mysql驱动包的前提之下，一个报错一个没报错，说明Druid在初始化的时候没有加载驱动，而C3P0刚好相反
  - Druid程序运行虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取链接的时候，也会找不到驱动类的错误



### 加载properties配置文件

包含了一些问题

- 这两个数据源中都使用到了一些固定的常量如数据库连接四个要素，把这些值写在Spring的配置文件中不利于后期的维护

- 需要将这些值提取到一个外部的properties配置文件中
- Spring框架中如何从配置文件中读取属性值来配置就是接下来的问题



第三方bean属性优化

##### 实现思路

> 需求:将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。
>
> 1.在resources下创建一个jdbc.properties(文件的名称可以任意)
>
> 2.将数据库连接四要素配置到配置文件中
>
> 3.在Spring的配置文件中加载properties文件
>
> 4.使用加载到的值实现属性注入
>
> 其中第3，4步骤是重点关注的，具体是如何实现。

##### 实现步骤

准备好properties配置文件

resource下创建一个jdbc.properties文件，并添加对应的属性键值对

```
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/Database_name
jdbc.username=root
jdbc.password=root
```

在applicationContext.xml中开context命名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">         
</beans>
```



使用${key}来读取properties配置文件中的内容并完成属性注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    
    
    <context:property-placeholder location="jdbc.properties"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```



### **读取单个属性**



```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">

    <bean id="bookDao" class="com.ityueheng.dao.impl.BookDaoImpl">    </bean>

    <bean id="userDao" class="com.ityueheng.User.impl.UserDaoImpl">    </bean>
    <bean id="bookService" class="com.ityueheng.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
        <property name="userDao" ref="userDao"/>
    </bean>

<!--    直接对实体类Student中的属性赋值-->
    <bean id="stu" class="com.ityueheng.pojo.Student">
        <property name="age" value="28"/>
        <property name="id" value="202110098141"/>
        <property name="name" value="林常恒"/>
    </bean>

    <context:property-placeholder location="jdbc.properties"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
    
    ***
    <bean id="bookDao1" class="com.ityueheng.dao.impl.BookDaoImpl">
        <property name="name" value="${jdbc.driver}"/>
    </bean>

</beans>
```



注意事项：

- 问题一：键值对的key为username引发的问题

1. 在properties中配置键值对的时候，如果key设置为username

```
username=root666
```

出现问题的原因是`<context:property-placeholder/>`标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量?

```java
public static void main(String[] args) throws Exception{
    Map<String, String> env = System.getenv();
    System.out.println(env);
}
```



```
    <context:property-placeholder location="jdbc.properties" system-properties-mode="NEVER"/>
```

system-properties-mode：设置为NEVER，表示不加载系统的属性，就可以解决上述问题

最好的解决方法就是避免使用username作为属性的key



当有多个properties配置文件需要被加载，该如何配置?

1.调整下配置文件的内容，在resources下添加`jdbc.properties`,`jdbc2.properties`,内容如下:

jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db
jdbc.username=root
jdbc.password=root
```

jdbc2.properties

```properties
username=root666
```



```xml
方式一：
<context:property-placeholder location="jdbc.properties,jdbc2.properties" system-properties-mode="NEVER">
    方式二：
    <context:property-placeholder location="*.properties" system-properties-mode="NEVER">
        方式三：
            <context:property-placeholder location="classpath:*.properties" system-properties-mode="NEVER">
                方式四：
                      <context:property-placeholder location="classpath*:*.properties" system-properties-mode="NEVER">
```

- 方式一：可以实现，如果配置文件多的话，每个都需要配置
- 方式二：*.properties代表的是所有
- 方式三：标准写法，classpath：代表的是从根路径开始查找，但是只能查询到当前项目的路径
- 方式四：不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件

































































































































![image-20221209091913181](java-SSM.assets/image-20221209091913181.png)

![image-20221209093248647](java-SSM.assets/image-20221209093248647.png)







# AOP简介：

Aop就是在不改变原有的代码的情况下，对其进行增强

## 什么是AOP?

* AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构。
  * OOP(Object Oriented Programming)面向对象编程

OOP是一种编程思想，那么AOP也是一种编程思想，编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的`编程范式`。

### AOP作用

- 作用:在不惊动原始设计的基础上为其进行功能增强，前面咱们有技术就可以实现这样的功能即代理模式。

前面咱们有技术就可以实现这样的功能即`代理模式`。



```java
@Repository
public class BookDaoImpl implements BookDao {
    public void save() {
        //记录程序当前执行执行（开始时间）
        Long startTime = System.currentTimeMillis();
        //业务执行万次
        for (int i = 0;i<10000;i++) {
            System.out.println("book dao save ...");
        }
        //记录程序当前执行时间（结束时间）
        Long endTime = System.currentTimeMillis();
        //计算时间差
        Long totalTime = endTime-startTime;
        //输出信息
        System.out.println("执行万次消耗时间：" + totalTime + "ms");
    }
    public void update(){
        System.out.println("book dao update ...");
    }
    public void delete(){
        System.out.println("book dao delete ...");
    }
    public void select(){
        System.out.println("book dao select ...");
    }
}
```

![image-20221210162709917](java-SSM.assets/image-20221210162709917.png)

这段代码的其他方法(update()，delete()，select())也能够增加跟save()方法一样的功能。

在不惊动(改动)原有设计(代码)的前提下，想给谁添加功能就给谁添加。这个也就是Spring的理念：

* 无入侵式/无侵入式



![image-20221210162641272](java-SSM.assets/image-20221210162641272.png)



* 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等
  * 在SpringAOP中，理解为方法的执行
* 切入点(Pointcut):匹配连接点的式子
  * 在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法
    * 一个具体的方法:如com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法
    * 匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法
  * 连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。
* 通知(Advice):在切入点处执行的操作，也就是共性功能
  * 在SpringAOP中，功能最终以方法的形式呈现
* 通知类：定义通知的类
* 切面(Aspect):描述通知与切入点的对应关系。



### AOP入门案例

设定：在方法执行前输出当前系统时间。



采用注解完成AOP的开发。





> 1.导入坐标(pom.xml)         
>
> 2.制作连接点(原始操作，Dao接口与实现类)
>
> 3.制作共性功能(通知类与通知)
>
> 4.定义切入点
>
> 5.绑定切入点与通知关系(切面)



### 2.4 AOP实现步骤

#### 步骤1:添加依赖

pom.xml

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.4</version>
</dependency>
```

![1630146885493](java-SSM.assets/1630146885493.png)

* 因为`spring-context`中已经导入了`spring-aop`,所以不需要再单独导入`spring-aop`
* 导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。

#### 步骤2:定义接口与实现类



#### 步骤3:定义通知类和通知

通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。

```java
public class MyAdvice {
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

#### 步骤4:定义切入点

BookDaoImpl中有两个方法，分别是save和update，我们要增强的是update方法，该如何定义呢?

```java
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")   //定义通式子
    private void pt(){}
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行==位置==

![1630148447689](java-SSM.assets/1630148447689.png)

**说明:**@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行



#### 步骤6:将通知类配给容器并标识其为切面类

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

#### 步骤7:开启注解格式AOP功能

```java
@Configuration
@ComponentScan("com.itheima")
@EnableAspectJAutoProxy
public class SpringConfig {
}
```



### 知识点1：@EnableAspectJAutoProxy  

| 名称 | @EnableAspectJAutoProxy |
| ---- | ----------------------- |
| 类型 | 配置类注解              |
| 位置 | 配置类定义上方          |
| 作用 | 开启注解格式AOP功能     |

### 知识点2：@Aspect

| 名称 | @Aspect               |
| ---- | --------------------- |
| 类型 | 类注解                |
| 位置 | 切面类定义上方        |
| 作用 | 设置当前类为AOP切面类 |

### 知识点3：@Pointcut   

| 名称 | @Pointcut                   |
| ---- | --------------------------- |
| 类型 | 方法注解                    |
| 位置 | 切入点方法定义上方          |
| 作用 | 设置切入点方法              |
| 属性 | value（默认）：切入点表达式 |

### 知识点4：@Before

| 名称 | @Before                                                      |
| ---- | ------------------------------------------------------------ |
| 类型 | 方法注解                                                     |
| 位置 | 通知方法定义上方                                             |
| 作用 | 设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 |



### AOP工作流程

由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起:

#### 流程1:Spring容器启动

* 容器启动就需要去加载bean,哪些类需要被加载呢?
* 需要被增强的类，如:BookServiceImpl
* 通知类，如:MyAdvice
* 注意此时bean对象还没有创建成功

#### 流程2:读取所有切面配置中的切入点

![1630151682428](java-SSM.assets/1630151682428.png)

* 上面这个例子中有两个切入点的配置，但是第一个`ptx()`并没有被使用，所以不会被读取。

#### 流程3:初始化bean，

判定bean对应的类中的方法是否匹配到任意切入点

* 注意第1步在容器启动的时候，bean对象还没有被创建成功。

* 要被实例化bean对象的类中的方法和切入点进行匹配

  ![1630152538083](java-SSM.assets/1630152538083.png)

  * 匹配失败，创建原始对象,如`UserDao`
    * 匹配失败说明不需要增强，直接调用原始对象的方法即可。
  * 匹配成功，创建原始对象（==目标对象==）的==代理==对象,如:`BookDao`
    * 匹配成功说明需要对其进行增强
    * 对哪个类做增强，这个类对应的对象就叫做目标对象
    * 因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象
    * 最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强

#### 流程4:获取bean执行方法

* 获取的bean是原始对象时，调用方法并执行，完成操作
* 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作

#### 验证容器中是否为代理对象

为了验证IOC容器中创建的对象和我们刚才所说的结论是否一致，首先先把结论理出来:

* 如果目标对象中的方法会被增强，那么容器中将存入的是目标对象的代理对象
* 如果目标对象中的方法不被增强，那么容器中将存入的是目标对象本身。

##### 步骤1:修改App类,获取类的类型

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class);
        System.out.println(bookDao);
        System.out.println(bookDao.getClass());
    }
}
```

##### 步骤2:修改MyAdvice类，不增强

因为定义的切入点中，被修改成`update1`,所以BookDao中的update方法在执行的时候，就不会被增强，

所以容器中的对象应该是目标对象本身。

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update1())")
    private void pt(){}
    
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

##### 步骤3:运行程序

![1630154495165](java-SSM.assets/1630154495165.png)

##### 步骤4:修改MyAdvice类，增强

因为定义的切入点中，被修改成`update`,所以BookDao中的update方法在执行的时候，就会被增强，

所以容器中的对象应该是目标对象的代理对象

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Before("pt()")
    public void method(){
        System.out.println(System.currentTimeMillis());
    }
}
```

##### 步骤5:运行程序

![1630154625564](java-SSM.assets/1630154625564.png)



描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法

```java
execution(void com.itheima.dao.BookDao.update())
```

描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法

```
execution(void com.itheima.dao.impl.BookDaoImpl.update())
```

对于切入点表达式的语法为:

* 切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）

对于这个格式，不需要硬记，通过一个例子，理解它:

```
execution(public User com.itheima.service.UserService.findById(int))
```

* execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点
* public:访问修饰符,还可以是public，private等，可以省略
* User：返回值，写返回值类型
* com.itheima.service：包名，多级包使用点连接
* UserService:类/接口名称
* findById：方法名
* int:参数，直接写参数的类型，多个类型用逗号隔开
* 异常名：方法定义中抛出指定异常，可以省略

切入点表达式就是要找到需要增强的方法



### 语法格式和通配符号

* `*`:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现

  ```
  execution（public * com.itheima.*.UserService.find*(*))
  ```

  匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法

* `..`：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写

  ```
  execution（public User com..UserService.findById(..))
  ```

  匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法

* `+`：专用于匹配子类类型

  ```
  execution(* *..*Service+.*(..))
  ```

  这个使用率较低，描述子类的，继承机会就一次，使用都很慎重，所以很少用它。*Service+，表示所有以Service结尾的接口的子类。





![1630163744963](java-SSM.assets/1630163744963.png)

```java
execution(void com.itheima.dao.BookDao.update())
匹配接口，能匹配到
execution(void com.itheima.dao.impl.BookDaoImpl.update())
匹配实现类，能匹配到
execution(* com.itheima.dao.impl.BookDaoImpl.update())
返回值任意，能匹配到
execution(* com.itheima.dao.impl.BookDaoImpl.update(*))
返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数
execution(void com.*.*.*.*.update())
返回值为void,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配
execution(void com.*.*.*.update())
返回值为void,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配
execution(void *..update())
返回值为void，方法名是update的任意包下的任意类，能匹配
execution(* *..*(..))
匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广
execution(* *..u*(..))
匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配
execution(* *..*e(..))
匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配
execution(void com..*())
返回值为void，com包下的任意包任意类任意方法，能匹配，*代表的是方法
execution(* com.itheima.*.*Service.find*(..))
将项目中所有业务层方法的以find开头的方法匹配
execution(* com.itheima.*.*Service.save*(..))
将项目中所有业务层方法的以save开头的方法匹配
```

后面两种更符合我们平常切入点表达式的编写规则



#### 书写技巧

对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:

- 所有代码按照标准规范开发，否则以下技巧全部失效
- 描述切入点通**==常描述接口==**，而不描述实现类,如果描述到实现类，就出现紧耦合了
- 访问控制修饰符针对接口开发均采用public描述（**==可省略访问控制修饰符描述==**）
- 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用\*通配快速描述
- **==包名==**书写**==尽量不使用..匹配==**，效率过低，常用\*做单个包描述匹配，或精准匹配
- **==接口名/类名==**书写名称与模块相关的**==采用\*匹配==**，例如UserService书写成\*Service，绑定业务层接口名
- **==方法名==**书写以**==动词==**进行**==精准匹配==**，名词采用*匹配，例如getById书写成getBy*,selectAll书写成selectAll
- 参数规则较为复杂，根据业务方法灵活调整
- 通常**==不使用异常==**作为**==匹配==**规则



共提供了5种通知类型:

- 前置通知
- 后置通知
- **==环绕通知(重点)==**
- 返回后通知(了解)
- 抛出异常后通知(了解)



![1630166147697](java-SSM.assets/1630166147697.png)

(1)前置通知，追加功能到方法执行前,类似于在代码1或者代码2添加内容

(2)后置通知,追加功能到方法执行后,不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容

(3)返回后通知,追加功能到方法执行后，只有方法正常执行结束后才进行,类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加

(4)抛出异常后通知,追加功能到方法抛出异常后，只有方法执行出异常才进行,类似于在代码4添加内容，只有方法抛出异常后才会被添加

(5)环绕通知,环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能



##### 前置通知

修改MyAdvice,在before方法上添加`@Before注解`

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Before("pt()")
    //此处也可以写成 @Before("MyAdvice.pt()"),不建议
    public void before() {
        System.out.println("before advice ...");
    }
}
```



##### 后置通知

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Before("pt()")
    public void before() {
        System.out.println("before advice ...");
    }
    @After("pt()")
    public void after() {
        System.out.println("after advice ...");
    }
}
```



##### 环绕通知

###### 基本使用



```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Around("pt()")
    public void around(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println("around before advice ...");
        //表示对原始操作的调用
        pjp.proceed();
        System.out.println("around after advice ...");
    }
}
```

标准格式：

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Pointcut("execution(int com.itheima.dao.BookDao.select())")
    private void pt2(){}
    
    @Around("pt2()")
    public Object aroundSelect(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("around before advice ...");
        //表示对原始操作的调用
        Object ret = pjp.proceed();
        System.out.println("around after advice ...");
        return ret;
    }
}
```



**说明:**

​	为什么返回的是Object而不是int的主要原因是Object类型更通用。

​	在环绕通知中是可以对原始方法返回值就行修改的。







##### 返回后通知

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Pointcut("execution(int com.itheima.dao.BookDao.select())")
    private void pt2(){}
    
    @AfterReturning("pt2()")
    public void afterReturning() {
        System.out.println("afterReturning advice ...");
    }
}
```



##### 异常后通知

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")
    private void pt(){}
    
    @Pointcut("execution(int com.itheima.dao.BookDao.select())")
    private void pt2(){}
    
    @AfterReturning("pt2()")
    public void afterThrowing() {
        System.out.println("afterThrowing advice ...");
    }
}
```



因为环绕通知是可以控制原始方法执行的，所以把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如:

![1630170090945](java-SSM.assets/1630170090945.png)

##### 

#### 获取参数

##### 非环绕通知获取方式

在方法上添加JoinPoint,通过JoinPoint来获取参数

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @Before("pt()")
    public void before(JoinPoint jp) 
        Object[] args = jp.getArgs();
        System.out.println(Arrays.toString(args));
        System.out.println("before advice ..." );
    }
	//...其他的略
}
```



![1630233291929](java-SSM.assets/1630233291929.png)

参数的个数是不固定的，所以使用数组更通配些。



##### 环绕通知获取方式

环绕通知使用的是ProceedingJoinPoint，因为ProceedingJoinPoint是JoinPoint类的子类，所以对于ProceedingJoinPoint类中应该也会有对应的`getArgs()`方法

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp)throws Throwable {
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        Object ret = pjp.proceed();
        return ret;
    }
	//其他的略
}
```

运行App后查看运行结果，说明ProceedingJoinPoint也是可以通过getArgs()获取参数

![1630233974310](java-SSM.assets/1630233974310.png)



* pjp.proceed()方法是有两个构造方法，分别是:

  ![1630234756123](java-SSM.assets/1630234756123.png)

  * 调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数

  * 所以调用这两个方法的任意一个都可以完成功能

  * 但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下:

    ```java
    @Component
    @Aspect
    public class MyAdvice {
        @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
        private void pt(){}
    
        @Around("pt()")
        public Object around(ProceedingJoinPoint pjp) throws Throwable{
            Object[] args = pjp.getArgs();
            System.out.println(Arrays.toString(args));
            args[0] = 666;
            Object ret = pjp.proceed(args);
            return ret;
        }
    	//其他的略
    }
    ```

    有了这个特性后，就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性。

#### 获取返回值

对于返回值，只有返回后`AfterReturing`和环绕`Around`这两个通知类型可以获取，具体如何获取?

##### 环绕通知获取返回值

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable{
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        args[0] = 666;
        Object ret = pjp.proceed(args);
        return ret;
    }
	//其他的略
}
```

上述代码中，`ret`就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改。



##### 返回后通知获取返回值

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @AfterReturning(value = "pt()",returning = "ret")
    public void afterReturning(Object ret) {
        System.out.println("afterReturning advice ..."+ret);
    }
	//其他的略
}
```

==注意:==

(1)参数名的问题

![1630237320870](java-SSM.assets/1630237320870.png)

(2)afterReturning方法参数类型的问题

参数类型可以写成String，但是为了能匹配更多的参数类型，最好写成Object类型

(3)afterReturning方法参数的顺序问题

![1630237586682](java-SSM.assets/1630237586682.png)

运行App后查看运行结果，说明返回值已经被获取到

![1630237372286](java-SSM.assets/1630237372286.png)

#### 

#### 获取异常

对于获取抛出的异常，只有抛出异常后`AfterThrowing`和环绕`Around`这两个通知类型可以获取

##### 环绕通知获取异常

只需要将异常捕获，就可以获取到原始方法的异常信息

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp){
        Object[] args = pjp.getArgs();
        System.out.println(Arrays.toString(args));
        args[0] = 666;
        Object ret = null;
        try{
            ret = pjp.proceed(args);
        }catch(Throwable throwable){
            t.printStackTrace();
        }
        return ret;
    }
	//其他的略
}
```

在catch方法中就可以获取到异常

##### 抛出异常后通知获取异常

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(* com.itheima.dao.BookDao.findName(..))")
    private void pt(){}

    @AfterThrowing(value = "pt()",throwing = "t")
    public void afterThrowing(Throwable t) {
        System.out.println("afterThrowing advice ..."+t);
    }
	//其他的略
}
```

让原始方法抛出异常

```java
@Repository
public class BookDaoImpl implements BookDao {

    public String findName(int id,String password) {
        System.out.println("id:"+id);
        if(true){
            throw new NullPointerException();
        }
        return "itcast";
    }
}
```

==注意:==

![1630239939043](java-SSM.assets/1630239939043.png)

异常信息

![1630239997560](java-SSM.assets/1630239997560.png)







## 百度网盘密码数据兼容处理

#### 需求分析

需求: 对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理。

![1630240203033](java-SSM.assets/1630240203033.png)

问题描述:

* 点击链接，会提示，请输入提取码

  ![1630240528228](java-SSM.assets/1630240528228.png)



#### 具体实现

##### 步骤1:开启SpringAOP的注解功能

```java
@Configuration
@ComponentScan("com.ityueheng")
@EnableAspectJAutoProxy
public class SpringConfig {
}
```

##### 步骤2:编写通知类

```java
@Component
@Aspect
public class DataAdvice {
    @Pointcut("execution(boolean com.ityueheng.service.*Service.*(*,*))")
    private void servicePt(){}
    
}
```

##### 步骤3:添加环绕通知

```java
@Component
@Aspect
public class DataAdvice {
    @Pointcut("execution(boolean com.ityueheng.service.*Service.*(*,*))")
    private void servicePt(){}
    
    @Around("DataAdvice.servicePt()")
    // @Around("servicePt()")这两种写法都对
    public Object trimStr(ProceedingJoinPoint pjp) throws Throwable {
        Object ret = pjp.proceed();
        return ret;
    }
    
}
```

##### 步骤4:完成核心业务，处理参数中的空格

```java
@Component
@Aspect
public class DataAdvice {
    @Pointcut("execution(boolean com.ityueheng.service.*Service.*(*,*))")
    private void servicePt(){}
    
    @Around("DataAdvice.servicePt()")
    // @Around("servicePt()")这两种写法都对
    public Object trimStr(ProceedingJoinPoint pjp) throws Throwable {
        //获取原始方法的参数
        Object[] args = pjp.getArgs();
        for (int i = 0; i < args.length; i++) {
            //判断参数是不是字符串
            if(args[i].getClass().equals(String.class)){
                args[i] = args[i].toString().trim();
            }
        }
        //将修改后的参数传入到原始方法的执行中
        Object ret = pjp.proceed(args);
        return ret;
    }
    
}
```

##### 步骤5:运行程序

不管密码`root`前后是否加空格，最终控制台打印的都是true

##### 步骤6:优化测试

为了能更好的看出AOP已经生效，我们可以修改ResourcesImpl类，在方法中将密码的长度进行打印

```java
@Repository
public class ResourcesDaoImpl implements ResourcesDao {
    public boolean readResources(String url, String password) {
        System.out.println(password.length());
        //模拟校验
        return password.equals("root");
    }
}
```

再次运行成功，就可以根据最终打印的长度来看看，字符串的空格有没有被去除掉。

**注意：**

![1630242491831](java-SSM.assets/1630242491831.png)

## 

## AOP总结

### AOP的核心概念：

概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式

作用：就是在不惊动原始代码的情况下为方法增加功能

核心概念

- 代理（proxy）:SpringAOP的核心本质就是采用代理模式来实现的
- 连接点(JoinPoint)：在springAOP中，理解为任意方法的执行
- 切入点(Poincut)：匹配连接点的式子，也是具有共性功能的方法描述
- 通知(Advice)：若干个方法的共性功能，在切入点执行，最终体现为一个方法
- 切面(Aspect):描述切入点和通知的对应关系
- 目标对象(Target)：被代理的原始对象成为目标对象



### 切入点表达式

- 切入点标准表达式格式:动作关键字(访问修饰符 返回值类型 包名.类/接口名.方法名（参数）异常名)

```
execution(* com.itheima.service.*service.*(..))
```

切入点表达式描述通配符：

- 作用：用于快速描述，范围描述
- *:匹配任意的符号（常用）
- ..：匹配多个连续的任意符号(常用)
- +:匹配子类类型



切入点表达是书写技巧

1. 按照标准的规范开发
2. 查询操作的返回值建议使用*匹配
3. 减少适用..的形式描述包
4. 对接口进行描述，使用表示模块名称，例如UserService的匹配描述为*Service
5. 方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy*
6. 参数根据实际情况灵活进行调整



### 五种通知类型

- 前置通知
- 后置通知
- 环绕通知(重点)
  - 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用
  - 环绕通知可以隔离原始方法的调用执行
  - 环绕通知返回值设置为Object类型
  - 环绕通知中可以对原始方法调用过程中出现的异常进行处理
- 返回后通知
- 抛出异常后通知



### 通知中获取参数

- 获取切入点方法的参数，所有的通知类型都可以获取参数

JoinPoint:适用于前置、后置、返回后、抛出异常后通知

proceedingJoinPoint：适用于环绕通知

- 获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究
  - 返回后通知
  - 环绕通知
- 获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究
  - 抛出异常后通知
  - 环绕通知

## 



## AOP事务管理



















